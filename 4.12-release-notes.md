(As new features get added to 4.12, please link commits or pull requests here with a short description of the change.)

### [Pull request #542:](https://github.com/KentBeck/junit/pull/542) Customized failure message for `ExceptionRule`

`ExceptionRule` now allows one to customize the failure message thrown when the test does not throw the expected exception. For example example:
```
thrown.reportMissingExceptionWithMessage("FAIL: Expected exception to be thrown");
```
If a custom failure message is not provided a default message is used.

### [Pull request #549:](https://github.com/KentBeck/junit/pull/549) `@DataPoints`-annotated methods can now yield `null` values

Up until JUnit 4.11 a `@DataPoints`-annotated array field could contain null values, but the array returned by a `@DataPoints`-annotated method could not. This asymmetry has been resolved: _both_ can now provide a `null` data point. 

### [Pull request #544:](https://github.com/KentBeck/junit/pull/544) New constructor and factories in `Timeout`

`Timeout` deprecated the old constructor `Timeout(int millis)`.
A new constructor is available `TimeUnit(long timeout, TimeUnit unit)`. It enables you to use more confortable time units like `NANOSECONDS`, `MICROSECONDS`, `MILLISECONDS`, and `SECONDS`. Examples:

`@Rule public final TestRule globalTimeout = new Timeout(50, TimeUnit.MILLISECONDS);`

`@Rule public final TestRule globalTimeout = new Timeout(10, TimeUnit.SECONDS);`

and factory methods in `Timeout`:

`@Rule public final TestRule globalTimeout = Timeout.millis(50);`

`@Rule public final TestRule globalTimeout = Timeout.seconds(10);`

This usage avoids the truncation, which was the problem in the deprecated constructor `Timeout(int millis)` when casting long to integer.

### [Pull request #564:](https://github.com/KentBeck/junit/pull/564) Allow configurable creation of child runners of parameterized suites

The `Parameterized` runner can be subclassed to implement a different logic for the creation of child runners.

You can override the `createRunner()` method to create a new `Runner` instance. This method is called once for every group of parameters and will receive as input the name pattern (specified by the `@Parameters` annotation), an index and the array of parameter values.

The default behaviour of child runners is implemented by the `TestClassRunnerForParameters` inner class. You can override this class to create your child runners if you want to retain most of the default beahaviour. In particular, you can implement your own formatting logic for the name of the runner by overriding the `nameFor()` method.

### [Pull request #552:](https://github.com/KentBeck/junit/pull/552) Stopwatch rule

The Stopwatch Rule notifies one of its own protected methods of the time spent by a test. Override them to get the time in nanoseconds. For example, this class will keep logging the time spent by each passed, failed, skipped, and finished test:

```
public static class StopwatchTest {
    private static final Logger logger= Logger.getLogger("");

    private static void logInfo(String testName, String status, long nanos) {
        logger.info(String.format("Test %s %s, spent %d microseconds",
                                    testName, status, Stopwatch.toMicros(nanos)));
    }

    @Rule
    public Stopwatch stopwatch= new Stopwatch() {
        @Override
        protected void succeeded(long nanos, Description description) {
            logInfo(description.getMethodName(), "succeeded", nanos);
        }

        @Override
        protected void failed(long nanos, Throwable e, Description description) {
            logInfo(description.getMethodName(), "failed", nanos);
        }

        @Override
        protected void skipped(long nanos, AssumptionViolatedException e, Description description) {
            logInfo(description.getMethodName(), "skipped", nanos);
        }

        @Override
        protected void finished(long nanos, Description description) {
            logInfo(description.getMethodName(), "finished", nanos);
        }
    };

    @Test
    public void succeeds() {
    }

    @Test
    public void fails() {
        fail();
    }

    @Test
    public void skips() {
        assumeTrue(false);
    }
}
```

